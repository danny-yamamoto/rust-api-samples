---
title: "Rust vs. Go: Learning Dependency Injection"
emoji: "ğŸš€"
type: "tech" # tech: æŠ€è¡“è¨˜äº‹ / idea: ã‚¢ã‚¤ãƒ‡ã‚¢
topics: ["rust", "go"]
published: false
---
Rust åˆå¿ƒè€…ã¨ã—ã¦ã€Production ã®æ§‹æˆã‚’å­¦ã¶ã€‚

å½“ç„¶ã€Production ã«ãŠã„ã¦ã€`main.rs` ã ã‘ã§æ§‹æˆã™ã‚‹ã“ã¨ã¯ãªã„ã€‚

Test æˆ¦ç•¥ã‚’å«ã‚ã€architecture ãŒå¿…è¦ã€‚

architecture ã¯ã€å€‹äººçš„ã«ã¯ã€ãƒ†ã‚¹ãƒˆå¯èƒ½ãªã‚³ãƒ¼ãƒ‰ã§ã‚ã‚Œã°è‰¯ã„ã¨æ€ã†ã€‚ã“ã“æ•°å¹´ã€DDD ã‚„ Clean ãªã©ã€è‰²ã€…ãªè¨­è¨ˆãŒæµè¡Œã—ã¦ã„ã‚‹ãŒã€‚

æœ€ä½é™ã€è‡ªå‹•ãƒ†ã‚¹ãƒˆã‚’å¯èƒ½ã«ã™ã‚‹ã«ã¯ã€æŠ½è±¡åŒ–ãŒå¿…è¦ã«ãªã‚‹ã€‚

Database ã‚„ API ãªã©ã€status ã‚’æŒã¤å¤–éƒ¨é–¢ä¿‚ã‚’æŠ½è±¡åŒ–ã§ãã‚Œã°ã€domain logic ã¯ç¹°ã‚Šè¿”ã—ãƒ†ã‚¹ãƒˆå¯èƒ½ã€‚

ãã‚Œã‚’å®Ÿç¾ã™ã‚‹ã€‚

## Implementing Dependency Inversion(DI) in Rust
å®Ÿè£…ã®æ‰‹é †
1. ãƒ¦ãƒ¼ã‚¶ãƒ¼ã¨ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ã«é–¢ã™ã‚‹æ“ä½œã‚’ãã‚Œãã‚Œã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã«åˆ†ã‘ã‚‹ã€‚
1. handler ã‚’å¤‰æ›´ã™ã‚‹ã€‚handler ã§ã‚µãƒ¼ãƒ“ã‚¹ã‚’ä½¿ç”¨ã™ã‚‹ã€‚
1. å‘¼ã³å‡ºã—å´ï¼ˆendpointã€ã“ã®å ´åˆã¯ `main.rs`ï¼‰ã§ã‚µãƒ¼ãƒ“ã‚¹ã‚’æ³¨å…¥ã™ã‚‹ã€‚

ã“ã‚Œã§ã€`fetch_user` `download_content` å˜ä½“ã§ãƒ†ã‚¹ãƒˆãŒå¯èƒ½ã«ã€‚

https://github.com/danny-yamamoto/rust-api-samples/blob/main/main/src/routes.rs

```diff
use std::sync::Arc;
use axum::Json;
use axum::http::StatusCode;
use axum::response::IntoResponse;
use axum::{Extension, extract::Query};
use cloud_storage::Client;
use sqlx::SqlitePool;
use model::UserQuery;

use crate::model::{StorageQuery, User, self, StorageResponse};

pub enum ApiResponse {
    UserResponse(Option<User>),
    StorageResponse(StorageResponse),
    ErrorResponse(String),
}

use axum::response::Response;

impl IntoResponse for ApiResponse {
    fn into_response(self) -> Response {
        match self {
            ApiResponse::UserResponse(user) => (StatusCode::OK, Json(user)).into_response(),
            ApiResponse::StorageResponse(storage) => (StatusCode::OK, Json(storage)).into_response(),
            ApiResponse::ErrorResponse(err) => (StatusCode::INTERNAL_SERVER_ERROR, Json(err)).into_response(),
        }
    }
}

- pub async fn user_handler(Query(query):Query<UserQuery>, Extension(pool):Extension<Arc<SqlitePool>>) -> impl IntoResponse {
-    let selected = query.user_id;
-    match sqlx::query_as!(User, "select user_id, email_address, created_at, deleted, settings from users where user_id = ?", selected).fetch_optional(&*pool).await {
-        Ok(user) => ApiResponse::UserResponse(user),
-        Err(_) => ApiResponse::ErrorResponse("Internal Server Error".to_string()),
-    }
- }
+ pub async fn user_handler(Query(query):Query<UserQuery>, Extension(user_service):Extension<Arc<UserService>>) -> impl IntoResponse {
+    match user_service.fetch_user(query.user_id).await {
+        Ok(user) => ApiResponse::UserResponse(user),
+        Err(_) => ApiResponse::ErrorResponse("Internal Server Error".to_string()),
+    }
+ }

- pub async fn storage_handler(Query(query):Query<StorageQuery>) -> impl IntoResponse {
-    let client = Client::default();
-    match client.object().download(&query.bucket, &query.object).await {
-        Ok(bytes) => ApiResponse::StorageResponse(StorageResponse { content: String::from_utf8_lossy(&bytes).to_string() }),
-        Err(error) => ApiResponse::ErrorResponse(error.to_string()),
-    }
- }
+ pub async fn storage_handler(Query(query):Query<StorageQuery>, Extension(storage_service):Extension<Arc<StorageService>>) -> impl IntoResponse {
+    match storage_service.download_content(&query).await {
+        Ok(content) => ApiResponse::StorageResponse(content),
+        Err(error) => ApiResponse::ErrorResponse(error.to_string()),
+    }
+ }

+ pub struct UserService {
+    pool: SqlitePool,
+ }
+
+ impl UserService {
+    pub fn new(pool: SqlitePool) -> Self {
+        UserService { pool }
+    }
+
+    pub async fn fetch_user(&self, user_id: i64) -> Result<Option<User>, sqlx::Error> {
+        sqlx::query_as!(User, "SELECT user_id, email_address, created_at, deleted, settings FROM users WHERE user_id = ?", user_id).fetch_optional(&self.pool).await
+    }
+ }
+
+ pub struct StorageService;
+
+ impl StorageService {
+    pub fn new() -> Self {
+        StorageService {}
+    }
+
+    pub async fn download_content(&self, query: &StorageQuery) -> Result<StorageResponse, String> {
+        let client = Client::default();
+        match client.object().download(&query.bucket, &query.object).await {
+            Ok(bytes) => Ok(StorageResponse { content: String::from_utf8_lossy(&bytes).to_string() }),
+            Err(error) => Err(error.to_string()),
+        }
+    }
+ }
```

## Rust to Go Conversion

https://github.com/danny-yamamoto/go-api-samples/blob/main/internal/users/users.go

```diff
```
