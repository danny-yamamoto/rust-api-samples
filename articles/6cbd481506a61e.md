---
title: "Rust vs. Go: Learning Dependency Injection"
emoji: "ğŸ…"
type: "tech" # tech: æŠ€è¡“è¨˜äº‹ / idea: ã‚¢ã‚¤ãƒ‡ã‚¢
topics: ["rust", "go"]
published: false
---
Rust åˆå¿ƒè€…ã¨ã—ã¦ã€Production ã®æ§‹æˆã‚’å­¦ã¶ã€‚

Production ã«ãŠã„ã¦ã€`main.rs` ã ã‘ã§æ§‹æˆã™ã‚‹ã“ã¨ã¯ãªã„ã€‚

Architecture ãŒå¿…è¦ã€‚

åƒ•å€‹äººã®æ„è¦‹ã¨ã—ã¦ã€Architecture ã¯ã€ãƒ†ã‚¹ãƒˆå¯èƒ½ãªã‚³ãƒ¼ãƒ‰ã§ã‚ã‚Œã°è‰¯ã„ã€‚ã“ã“æ•°å¹´ã€DDD ã‚„ Clean ãªã©ã€è‰²ã€…ãªè¨­è¨ˆãŒæµè¡Œã—ã¦ã„ã‚‹ãŒã€‚

æœ€ä½é™ã€è‡ªå‹•ãƒ†ã‚¹ãƒˆã‚’å¯èƒ½ã«ã™ã‚‹ã«ã¯ã€æŠ½è±¡åŒ–ãŒå¿…è¦ã«ãªã‚‹ã€‚

Database ã‚„ API ãªã©ã€status ã‚’æŒã¤å¤–éƒ¨é–¢ä¿‚ã‚’æŠ½è±¡åŒ–ã§ãã‚Œã°ã€domain logic ã¯ç¹°ã‚Šè¿”ã—ãƒ†ã‚¹ãƒˆå¯èƒ½ã€‚

ãã‚Œã‚’å®Ÿç¾ã™ã‚‹ã€‚

ã‚³ãƒ¼ãƒ‰ã¯ã“ã¡ã‚‰ã€‚

https://github.com/danny-yamamoto/rust-api-samples/tree/main/main

https://github.com/danny-yamamoto/go-api-samples

## Implementing Dependency Inversion(DI) in Rust
å®Ÿè£…ã®æ‰‹é †
1. `/users` ã¨ `/storage` ã«é–¢ã™ã‚‹æ“ä½œã‚’ãã‚Œãã‚Œã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã«åˆ†ã‘ã‚‹ã€‚
1. handler ã‚’å¤‰æ›´ã™ã‚‹ã€‚handler ã§ã‚µãƒ¼ãƒ“ã‚¹ã‚’ä½¿ç”¨ã™ã‚‹ã€‚
1. å‘¼ã³å‡ºã—å´ï¼ˆendpointã€ã“ã®å ´åˆã¯ `main.rs`ï¼‰ã§ã‚µãƒ¼ãƒ“ã‚¹ã‚’æ³¨å…¥ã™ã‚‹ã€‚

- ã“ã‚Œã§ã€`fetch_user` `download_content` å˜ä½“ã§ãƒ†ã‚¹ãƒˆãŒå¯èƒ½ã«ãªã£ãŸã€‚
- ApiResponse `enum` åˆ—æŒ™å‹ã«ã€`/users` ã®ãƒ¬ã‚¹ãƒãƒ³ã‚¹ã€`/storage` ã®ãƒ¬ã‚¹ãƒãƒ³ã‚¹ã€ãŠã‚ˆã³ã‚¨ãƒ©ãƒ¼ã®ãƒ¬ã‚¹ãƒãƒ³ã‚¹ã® 3 ç¨®é¡ã®ãƒãƒªã‚¢ãƒ³ãƒˆãŒã‚ã‚‹ã€‚ç•°ãªã‚‹ã‚¿ã‚¤ãƒ—ã®ãƒ¬ã‚¹ãƒãƒ³ã‚¹ã‚’æŸ”è»Ÿã«æ‰±ã†ã“ã¨ãŒã§ã‚‹ã€‚

https://github.com/danny-yamamoto/rust-api-samples/blob/main/main/src/routes.rs

```diff
use std::sync::Arc;
use axum::Json;
use axum::http::StatusCode;
use axum::response::IntoResponse;
use axum::{Extension, extract::Query};
use cloud_storage::Client;
use sqlx::SqlitePool;
use model::UserQuery;

use crate::model::{StorageQuery, User, self, StorageResponse};

pub enum ApiResponse {
    UserResponse(Option<User>),
    StorageResponse(StorageResponse),
    ErrorResponse(String),
}

use axum::response::Response;

impl IntoResponse for ApiResponse {
    fn into_response(self) -> Response {
        match self {
            ApiResponse::UserResponse(user) => (StatusCode::OK, Json(user)).into_response(),
            ApiResponse::StorageResponse(storage) => (StatusCode::OK, Json(storage)).into_response(),
            ApiResponse::ErrorResponse(err) => (StatusCode::INTERNAL_SERVER_ERROR, Json(err)).into_response(),
        }
    }
}

- pub async fn user_handler(Query(query):Query<UserQuery>, Extension(pool):Extension<Arc<SqlitePool>>) -> impl IntoResponse {
-    let selected = query.user_id;
-    match sqlx::query_as!(User, "select user_id, email_address, created_at, deleted, settings from users where user_id = ?", selected).fetch_optional(&*pool).await {
-        Ok(user) => ApiResponse::UserResponse(user),
-        Err(_) => ApiResponse::ErrorResponse("Internal Server Error".to_string()),
-    }
- }
+ pub async fn user_handler(Query(query):Query<UserQuery>, Extension(user_service):Extension<Arc<UserService>>) -> impl IntoResponse {
+    match user_service.fetch_user(query.user_id).await {
+        Ok(user) => ApiResponse::UserResponse(user),
+        Err(_) => ApiResponse::ErrorResponse("Internal Server Error".to_string()),
+    }
+ }

- pub async fn storage_handler(Query(query):Query<StorageQuery>) -> impl IntoResponse {
-    let client = Client::default();
-    match client.object().download(&query.bucket, &query.object).await {
-        Ok(bytes) => ApiResponse::StorageResponse(StorageResponse { content: String::from_utf8_lossy(&bytes).to_string() }),
-        Err(error) => ApiResponse::ErrorResponse(error.to_string()),
-    }
- }
+ pub async fn storage_handler(Query(query):Query<StorageQuery>, Extension(storage_service):Extension<Arc<StorageService>>) -> impl IntoResponse {
+    match storage_service.download_content(&query).await {
+        Ok(content) => ApiResponse::StorageResponse(content),
+        Err(error) => ApiResponse::ErrorResponse(error.to_string()),
+    }
+ }

+ pub struct UserService {
+    pool: SqlitePool,
+ }
+
+ impl UserService {
+    pub fn new(pool: SqlitePool) -> Self {
+        UserService { pool }
+    }
+
+    pub async fn fetch_user(&self, user_id: i64) -> Result<Option<User>, sqlx::Error> {
+        sqlx::query_as!(User, "SELECT user_id, email_address, created_at, deleted, settings FROM users WHERE user_id = ?", user_id).fetch_optional(&self.pool).await
+    }
+ }
+
+ pub struct StorageService;
+
+ impl StorageService {
+    pub fn new() -> Self {
+        StorageService {}
+    }
+
+    pub async fn download_content(&self, query: &StorageQuery) -> Result<StorageResponse, String> {
+        let client = Client::default();
+        match client.object().download(&query.bucket, &query.object).await {
+            Ok(bytes) => Ok(StorageResponse { content: String::from_utf8_lossy(&bytes).to_string() }),
+            Err(error) => Err(error.to_string()),
+        }
+    }
+ }
```

## Rust to Go Conversion
1. `New` é–¢æ•°ã®è¿½åŠ 
1. Handler æ§‹é€ ä½“åŠã³ NewHandler é–¢æ•°ã®å‰Šé™¤

ã“ã®å¤‰æ›´ã§ domain logic ã‚’å®Ÿè£…ã™ã‚‹ `GetUsers` é–¢æ•°ã® test code ã‚’å®Ÿè£…ã§ãã‚‹ã€‚

https://github.com/danny-yamamoto/go-api-samples/blob/main/internal/users/users.go

```diff
-type Handler struct {
-	db *sql.DB
-}
-
-func NewHandler(db *sql.DB) *Handler {
-	return &Handler{db: db}
-}
-
-func respondWithJSON(w http.ResponseWriter, statusCode int, payload interface{}) {
-	response, _ := json.Marshal(payload)
-	w.Header().Add("Content-Type", "application/json")
-	w.WriteHeader(statusCode)
-	w.Write(response)
-}
-
-func (h Handler) UserHandler(w http.ResponseWriter, r *http.Request) {
-	userId := r.URL.Query().Get("user_id")
-	var user User
-	err := h.db.QueryRow("select * from users where user_id = ?", userId).Scan(&user.UserId, &user.EmailAddress, &user.CreatedAt, &user.Deleted, &user.Settings)
-	if err != nil {
-		fmt.Println(err)
-		respondWithJSON(w, http.StatusInternalServerError, err)
-		return
-	}
-	respondWithJSON(w, http.StatusOK, user)
-}
-
+type UserQuery struct {
+	UserId string `json:"user_id"`
 }

+func GetUsers(db *sql.DB, query UserQuery) (*User, error) {
+	userId := query.UserId
+	var user User
+	err := db.QueryRow("select * from users where user_id = ?", userId).Scan(&user.UserId, &user.EmailAddress, &user.CreatedAt, &user.Deleted, &user.Settings)
+	if err != nil {
+		log.Printf("Query Error: %s", err)
+		return nil, err
+	}
+	return &user, nil
+}
+
+// Factory Function
+func New(db *sql.DB) http.HandlerFunc {
+	return func(w http.ResponseWriter, r *http.Request) {
+		query := UserQuery{UserId: r.URL.Query().Get("user_id")}
+		data, err := GetUsers(db, query)
+		if err != nil {
+			http.Error(w, err.Error(), http.StatusInternalServerError)
+			return
+		}
+		json.NewEncoder(w).Encode(data)
+	}
+}
```
