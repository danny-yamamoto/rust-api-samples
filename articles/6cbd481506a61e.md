---
title: "Rust vs. Go: Learning Dependency Injection"
emoji: "ğŸ…"
type: "tech" # tech: æŠ€è¡“è¨˜äº‹ / idea: ã‚¢ã‚¤ãƒ‡ã‚¢
topics: ["rust", "go"]
published: false
---
[Retail AI Adventurers Advent Calendar 2023](https://qiita.com/advent-calendar/2023/rai-adventurers) ã®æŠ•ç¨¿ã§ã™ã€‚

https://qiita.com/advent-calendar/2023/rai-adventurers

[Retail AI](https://www.retail-ai.jp) ã¯ã€[ãƒˆãƒ©ã‚¤ã‚¢ãƒ«ã‚«ãƒ³ãƒ‘ãƒ‹ãƒ¼](https://www.trial-net.co.jp) ã‚’è»¸ã¨ã—ãŸå°å£²ã«ãŠã‘ã‚‹ãŠå®¢æ§˜ã®è²·ã„ç‰©ä½“é¨“ã®å‘ä¸Šã‚’ç›®æŒ‡ã™ä¼æ¥­ã§ã™ã€‚

ã“ã®æŠ•ç¨¿ã§ã¯ã€æœ¬æ¥­ï¼ˆSREï¼‰ã®ã‹ãŸã‚ã‚‰ã§å–ã‚Šçµ„ã‚€ Backend ã«ã¤ã„ã¦æ›¸ãã¾ã™ã€‚

é¡Œæã¯ã€Rust åˆå¿ƒè€…ã¨ã—ã¦è€ƒãˆã‚‹ Production Code ã§ã™ã€‚

Production Code ã«ãŠã„ã¦ã€`main.rs`[^6] ã ã‘ã§æ§‹æˆã™ã‚‹ã“ã¨ã¯ã€é€šå¸¸ãªã„ã¨æ€ã„ã¾ã™ã€‚

å¾“ã£ã¦ã€Architecture ãŒå¿…è¦ã§ã™ã€‚

ã“ã“æ•°å¹´ã€DDD[^1] ã‚„ Clean Architecture[^2] ãªã©ã€è‰²ã€…ãªè¨­è¨ˆæ‰‹æ³•ãŒè©±é¡Œã§ã™ã€‚
åƒ•å€‹äººã®æ„è¦‹ã¨ã—ã¦ã€Architecture ã¯ã€ãƒ†ã‚¹ãƒˆå¯èƒ½ãªã‚³ãƒ¼ãƒ‰ã§ã‚ã‚Œã°è‰¯ã„ã¨æ€ã„ã¾ã™ã€‚
æœ€ä½é™ã€è‡ªå‹•ãƒ†ã‚¹ãƒˆã‚’å¯èƒ½ã«ã™ã‚‹ã«ã¯ã€æŠ½è±¡åŒ–ãŒå¿…è¦ã«ãªã‚Šã¾ã™ã€‚

ä¾‹ãˆã°ã€Database ã‚„ å¤–éƒ¨ API ãªã©ã€state ã‚’æŒã¤å¤–éƒ¨é–¢ä¿‚ã‚’æŠ½è±¡åŒ–ã§ãã‚Œã°ã€Domain Logic ã¯ç¹°ã‚Šè¿”ã—ãƒ†ã‚¹ãƒˆå¯èƒ½ã«ãªã‚Šã¾ã™ã€‚

ä»Šå›ã€ãã‚Œã‚’å®Ÿç¾ã™ã‚‹æ–¹æ³•ã®1ã¤ã§ã‚ã‚‹ Dependency Injectionï¼ˆDIï¼‰[^3] ã®å®Ÿè£…ã«ã¤ã„ã¦æ›¸ã„ã¦ã„ãã¾ã™ã€‚

ã”å­˜çŸ¥ã®é€šã‚Šã€DI ã‚’ç”¨ã„ã‚‹ã“ã¨ã§ã€ä½æ°´æº–ã®ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆï¼ˆä¾‹ãˆã° Database Accessï¼‰ã® Domain logic ã®å˜ä½“ãƒ†ã‚¹ãƒˆãŒå®¹æ˜“ã«ãªã‚Šã¾ã™ã€‚

ã•ã‚‰ã«è©³ã—ãè¦‹ãŸã„æ–¹ã¯èª­ã¿ç¶šã‘ã¦ãã ã•ã„ã€‚

---

ã€ŒGo ã§ã¯ã“ã†æ›¸ãã€ã€ŒRust ã§ã¯ã“ã†æ›¸ãã€ã¨ã„ã†æ„Ÿã˜ã§æ¯”è¼ƒã—ã¾ã™ã€‚

ã‚³ãƒ¼ãƒ‰ã¯ã“ã¡ã‚‰ã§ã™ã€‚

https://github.com/danny-yamamoto/rust-api-samples/tree/main/main

https://github.com/danny-yamamoto/go-api-samples

## Implementing Dependency Inversion(DI) in Rust
Rust ã§ã®å®Ÿè£…ã®æ‰‹é †ã§ã™ã€‚
DI ã‚’å®Ÿè£…ã™ã‚‹å‰æ®µéšã¨ã—ã¦ã€`/users` ã¨ `/storage` ã¨ã„ã† API ã‚’ç”¨æ„ã—ã¾ã—ãŸã€‚
* `/users`: Databaseï¼ˆSQLite[^5]ï¼‰ã‹ã‚‰æŒ‡å®šã—ãŸ user ã®æƒ…å ±ã‚’å–å¾—ã™ã‚‹ API ã§ã™ã€‚
* `/storage`: Cloud Storage[^4] ã‹ã‚‰æŒ‡å®šã—ãŸ Ojbect ã‚’å–å¾—ã™ã‚‹ API ã§ã™ã€‚

ã“ã®2ã¤ã® API ã« DI ã‚’å®Ÿè£…ã—ã¾ã™ã€‚
1. `/users` ã¨ `/storage` ã«é–¢ã™ã‚‹æ“ä½œã‚’ãã‚Œãã‚Œã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã«åˆ†ã‘ã‚‹ã€‚
1. handler ã‚’å¤‰æ›´ã™ã‚‹ã€‚handler ã§ã‚µãƒ¼ãƒ“ã‚¹ã‚’ä½¿ç”¨ã™ã‚‹ã€‚
1. å‘¼ã³å‡ºã—å´ï¼ˆendpointã€ã“ã®å ´åˆã¯ `main.rs`ï¼‰ã§ã‚µãƒ¼ãƒ“ã‚¹ã‚’æ³¨å…¥ã™ã‚‹ã€‚

:::message
ãƒã‚¤ãƒ³ãƒˆã¯ã€ApiResponse `enum` åˆ—æŒ™å‹ã® `/users` ã®ãƒ¬ã‚¹ãƒãƒ³ã‚¹ã€`/storage` ã®ãƒ¬ã‚¹ãƒãƒ³ã‚¹ã€ãŠã‚ˆã³ã‚¨ãƒ©ãƒ¼ã®ãƒ¬ã‚¹ãƒãƒ³ã‚¹ã® 3 ç¨®é¡ã®ãƒãƒªã‚¢ãƒ³ãƒˆã§ã™ã€‚ç•°ãªã‚‹ã‚¿ã‚¤ãƒ—ã®ãƒ¬ã‚¹ãƒãƒ³ã‚¹ã‚’æŸ”è»Ÿã«æ‰±ã†ã“ã¨ãŒå‡ºæ¥ã¾ã™ã€‚
:::

ã“ã‚Œã§ã€`fetch_user` `download_content` å˜ä½“ã§ãƒ†ã‚¹ãƒˆãŒå¯èƒ½ã«ãªã‚Šã¾ã™ã€‚

https://github.com/danny-yamamoto/rust-api-samples/blob/main/main/src/routes.rs

```diff
use std::sync::Arc;
use axum::Json;
use axum::http::StatusCode;
use axum::response::IntoResponse;
use axum::{Extension, extract::Query};
use cloud_storage::Client;
use sqlx::SqlitePool;
use model::UserQuery;

use crate::model::{StorageQuery, User, self, StorageResponse};

pub enum ApiResponse {
    UserResponse(Option<User>),
    StorageResponse(StorageResponse),
    ErrorResponse(String),
}

use axum::response::Response;

impl IntoResponse for ApiResponse {
    fn into_response(self) -> Response {
        match self {
            ApiResponse::UserResponse(user) => (StatusCode::OK, Json(user)).into_response(),
            ApiResponse::StorageResponse(storage) => (StatusCode::OK, Json(storage)).into_response(),
            ApiResponse::ErrorResponse(err) => (StatusCode::INTERNAL_SERVER_ERROR, Json(err)).into_response(),
        }
    }
}

- pub async fn user_handler(Query(query):Query<UserQuery>, Extension(pool):Extension<Arc<SqlitePool>>) -> impl IntoResponse {
-    let selected = query.user_id;
-    match sqlx::query_as!(User, "select user_id, email_address, created_at, deleted, settings from users where user_id = ?", selected).fetch_optional(&*pool).await {
-        Ok(user) => ApiResponse::UserResponse(user),
-        Err(_) => ApiResponse::ErrorResponse("Internal Server Error".to_string()),
-    }
- }
+ pub async fn user_handler(Query(query):Query<UserQuery>, Extension(user_service):Extension<Arc<UserService>>) -> impl IntoResponse {
+    match user_service.fetch_user(query.user_id).await {
+        Ok(user) => ApiResponse::UserResponse(user),
+        Err(_) => ApiResponse::ErrorResponse("Internal Server Error".to_string()),
+    }
+ }

- pub async fn storage_handler(Query(query):Query<StorageQuery>) -> impl IntoResponse {
-    let client = Client::default();
-    match client.object().download(&query.bucket, &query.object).await {
-        Ok(bytes) => ApiResponse::StorageResponse(StorageResponse { content: String::from_utf8_lossy(&bytes).to_string() }),
-        Err(error) => ApiResponse::ErrorResponse(error.to_string()),
-    }
- }
+ pub async fn storage_handler(Query(query):Query<StorageQuery>, Extension(storage_service):Extension<Arc<StorageService>>) -> impl IntoResponse {
+    match storage_service.download_content(&query).await {
+        Ok(content) => ApiResponse::StorageResponse(content),
+        Err(error) => ApiResponse::ErrorResponse(error.to_string()),
+    }
+ }

+ pub struct UserService {
+    pool: SqlitePool,
+ }
+
+ impl UserService {
+    pub fn new(pool: SqlitePool) -> Self {
+        UserService { pool }
+    }
+
+    pub async fn fetch_user(&self, user_id: i64) -> Result<Option<User>, sqlx::Error> {
+        sqlx::query_as!(User, "SELECT user_id, email_address, created_at, deleted, settings FROM users WHERE user_id = ?", user_id).fetch_optional(&self.pool).await
+    }
+ }
+
+ pub struct StorageService;
+
+ impl StorageService {
+    pub fn new() -> Self {
+        StorageService {}
+    }
+
+    pub async fn download_content(&self, query: &StorageQuery) -> Result<StorageResponse, String> {
+        let client = Client::default();
+        match client.object().download(&query.bucket, &query.object).await {
+            Ok(bytes) => Ok(StorageResponse { content: String::from_utf8_lossy(&bytes).to_string() }),
+            Err(error) => Err(error.to_string()),
+        }
+    }
+ }
```

## Rust to Go Conversion
Rust ã§å®Ÿè£…ã—ãŸå†…å®¹ã¨åŒã˜ã‚‚ã®ã‚’ Go ã§å®Ÿè£…ã—ã¾ã™ã€‚
1. `New` é–¢æ•°ã‚’è¿½åŠ ã™ã‚‹ã€‚
1. Handler æ§‹é€ ä½“åŠã³ NewHandler é–¢æ•°ã‚’å‰Šé™¤ã™ã‚‹ã€‚

ã“ã®å¤‰æ›´ã§ Domain Logic ã‚’å®Ÿè£…ã™ã‚‹ `GetUsers` é–¢æ•°ã® Test Code ã‚’å®Ÿè£…ã§ãã¾ã™ã€‚

https://github.com/danny-yamamoto/go-api-samples/blob/main/internal/users/users.go

```diff
-type Handler struct {
-	db *sql.DB
-}
-
-func NewHandler(db *sql.DB) *Handler {
-	return &Handler{db: db}
-}
-
-func respondWithJSON(w http.ResponseWriter, statusCode int, payload interface{}) {
-	response, _ := json.Marshal(payload)
-	w.Header().Add("Content-Type", "application/json")
-	w.WriteHeader(statusCode)
-	w.Write(response)
-}
-
-func (h Handler) UserHandler(w http.ResponseWriter, r *http.Request) {
-	userId := r.URL.Query().Get("user_id")
-	var user User
-	err := h.db.QueryRow("select * from users where user_id = ?", userId).Scan(&user.UserId, &user.EmailAddress, &user.CreatedAt, &user.Deleted, &user.Settings)
-	if err != nil {
-		fmt.Println(err)
-		respondWithJSON(w, http.StatusInternalServerError, err)
-		return
-	}
-	respondWithJSON(w, http.StatusOK, user)
-}
-
+type UserQuery struct {
+	UserId string `json:"user_id"`
 }

+func GetUsers(db *sql.DB, query UserQuery) (*User, error) {
+	userId := query.UserId
+	var user User
+	err := db.QueryRow("select * from users where user_id = ?", userId).Scan(&user.UserId, &user.EmailAddress, &user.CreatedAt, &user.Deleted, &user.Settings)
+	if err != nil {
+		log.Printf("Query Error: %s", err)
+		return nil, err
+	}
+	return &user, nil
+}
+
+// Factory Function
+func New(db *sql.DB) http.HandlerFunc {
+	return func(w http.ResponseWriter, r *http.Request) {
+		query := UserQuery{UserId: r.URL.Query().Get("user_id")}
+		data, err := GetUsers(db, query)
+		if err != nil {
+			http.Error(w, err.Error(), http.StatusInternalServerError)
+			return
+		}
+		json.NewEncoder(w).Encode(data)
+	}
+}
```

ã“ã‚Œã¯ã€å®Œå…¨ãªä¸»è¦³ã§ã™ãŒã€ç‰¹å¾´ãŒå‡ºã¾ã™ã€‚

Go ã¯å†—é•·ã«è¦‹ãˆã¦èª°ãŒè¦‹ã¦ã‚‚åˆ†ã‹ã‚Šã‚„ã™ãã€Rust ã¯ç°¡æ½”ã§ã‚ã‚Š Compileã§å®‰å…¨æ€§ã‚’æ‹…ä¿ã—ã¦ãã‚Œã‚‹ã€‚Rust ã® `match` æ§‹æ–‡ã¯ Coding ä½“é¨“ã¨ã—ã¦ç´ æ™´ã‚‰ã—ã„ã¨æ€ã„ã¾ã—ãŸã€‚

ç°¡å˜ã§ã™ãŒã€DI ã«ã¤ã„ã¦ã¯ä»¥ä¸Šã§ã™ã€‚

ã“ã®æŠ•ç¨¿ã‚’ã¿ã¦ä½•ã‹å¾—ã‚‰ã‚ŒãŸæ–¹ã¯ã€ã„ã„ã­ â¤ï¸ ã‚’ãŠé¡˜ã„ã—ã¾ã™ã€‚

ãã‚Œã§ã¯ã€æ¬¡å›ã®ã‚¢ãƒ‰ã‚«ãƒ¬ã§ãŠä¼šã„ã—ã¾ã—ã‚‡ã†ã€‚ğŸ‘‹

## BTW
Rust ã® HTTP Server Crate[^8] ã¯ã€Axum[^7] ä»¥å¤–ã«ã‚‚ã„ãã¤ã‹é¸æŠè‚¢ãŒã‚ã‚Šã¾ã™ã€‚

ä¾‹ãˆã°ã€`Rocket` ã‚‚æ°—ã«ãªã‚Šã¾ã™ã€‚

https://rocket.rs/v0.5/news/2023-11-17-version-0.5/

å¸¸ã«ç¾çŠ¶ã‚’æ‰“ç ´ã—ã¦æ”¹å–„ã—ãŸã„ã¨ã„ã†äººé–“ã®æ¬²æ±‚ã¨ technology ã®é€²åŒ–ã‚’è¦‹ã¦ã„ã‚‹ã¨ã€ãƒ¯ã‚¯ãƒ¯ã‚¯ãŒæ­¢ã¾ã‚Šã¾ã›ã‚“ã€‚

[^1]: ãƒ‰ãƒ¡ã‚¤ãƒ³é§†å‹•è¨­è¨ˆã¨ã¯ã€ãƒ‰ãƒ¡ã‚¤ãƒ³ã®å°‚é–€å®¶ã‹ã‚‰ã®å…¥åŠ›ã«å¾“ã£ã¦ãƒ‰ãƒ¡ã‚¤ãƒ³ã«ä¸€è‡´ã™ã‚‹ã‚ˆã†ã«ã‚½ãƒ•ãƒˆã‚¦ã‚§ã‚¢ã‚’ãƒ¢ãƒ‡ãƒ«åŒ–ã™ã‚‹ã“ã¨ã«ç„¦ç‚¹ã‚’å½“ã¦ã‚‹ã‚½ãƒ•ãƒˆã‚¦ã‚§ã‚¢è¨­è¨ˆæ‰‹æ³•ã§ã‚ã‚‹ã€‚
[^2]: Clean Architectureã¯ã€ã‚½ãƒ•ãƒˆã‚¦ã‚§ã‚¢é–‹ç™ºã«ãŠã‘ã‚‹è¨­è¨ˆåŸå‰‡ã®ä¸€ã¤ã§ã€ã‚½ãƒ•ãƒˆã‚¦ã‚§ã‚¢ã®è¨­è¨ˆã‚’æ•´ç†ã—ã€ãƒ¡ãƒ³ãƒ†ãƒŠãƒ³ã‚¹æ€§ã€æ‹¡å¼µæ€§ã€ãƒ†ã‚¹ãƒˆå®¹æ˜“æ€§ã‚’é«˜ã‚ã‚‹ã“ã¨ã‚’ç›®çš„ã¨ã—ã¦ã„ã¾ã™ã€‚ã“ã®ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£ã¯ã€ãƒ­ãƒãƒ¼ãƒˆãƒ»Cãƒ»ãƒãƒ¼ãƒ†ã‚£ãƒ³ï¼ˆé€šç§°ã€Œã‚¢ãƒ³ã‚¯ãƒ«ãƒ»ãƒœãƒ–ã€ï¼‰ã«ã‚ˆã£ã¦æå”±ã•ã‚Œã¾ã—ãŸã€‚
[^3]: ã‚½ãƒ•ãƒˆã‚¦ã‚§ã‚¢è¨­è¨ˆã®åŸå‰‡ã®ä¸€ã¤ã§ã€SOLIDã®åŸå‰‡ã®ä¸€éƒ¨ã§ã™ã€‚
[^4]: éæ§‹é€ åŒ–ãƒ‡ãƒ¼ã‚¿ã‚’ä¿å­˜ã™ã‚‹ãŸã‚ã® Google Cloud ã®ãƒãƒãƒ¼ã‚¸ãƒ‰ ã‚µãƒ¼ãƒ“ã‚¹ã§ã™ã€‚ä¿å­˜ã§ãã‚‹ãƒ‡ãƒ¼ã‚¿é‡ã«åˆ¶é™ã¯ãªãã€ä¿å­˜ã—ãŸãƒ‡ãƒ¼ã‚¿ã‚’å¿…è¦ã«å¿œã˜ã¦ä½•åº¦ã§ã‚‚å–å¾—ã§ãã¾ã™ã€‚ 
[^5]: éå¸¸ã«è»½é‡ã§ç°¡æ˜“çš„ãªãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã§ã™ã€‚
[^6]: Rust ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã® Entry Point ã§ã™ã€‚`main` é–¢æ•°ãŒãƒ—ãƒ­ã‚°ãƒ©ãƒ ã®é–‹å§‹ç‚¹ã§ã™ã€‚é€šå¸¸ã€ã“ã® `main` é–¢æ•°ã¯ `main.rs` å†…ã«å®šç¾©ã•ã‚Œã¾ã™ã€‚
[^7]: https://docs.rs/axum/latest/axum/
[^8]: Rust ã®ã‚³ãƒ¼ãƒ‰ï¼ˆé–¢æ•°ã€æ§‹é€ ä½“ã€ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãªã©ï¼‰ã®é›†ã¾ã‚Šã§ã‚ã‚Šã€å†åˆ©ç”¨å¯èƒ½ãªãƒ©ã‚¤ãƒ–ãƒ©ãƒªã‚„å®Ÿè¡Œå¯èƒ½ãªãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‚’æ§‹ç¯‰ã™ã‚‹ãŸã‚ã«ä½¿ç”¨ã•ã‚Œã¾ã™ã€‚
