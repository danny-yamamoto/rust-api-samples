---
title: "Rust vs. Go: Implementing a REST API in SQLite"
emoji: "ğŸ£"
type: "tech" # tech: æŠ€è¡“è¨˜äº‹ / idea: ã‚¢ã‚¤ãƒ‡ã‚¢
topics: ["rust", "go", "sqlite", "devcontainer", "restapi"]
published: false
---
Backend ã®é–‹ç™ºè¨€èªé¸å®šã«ã¤ã„ã¦ã€ç¾è·ã§ã¯ Go ã‚’æ¨ã™å£°ãŒå¼·ã„ã€‚

ãªãœãªã‚‰ã€ç¾çŠ¶ã®æŠ€è¡“é¸å®šã«ã€è¦å¾‹ãŒãªã„ã‹ã‚‰ã ã€‚Javaã€Pythonã€Rubyã€PHPã€Node.jsã€Goã€Kotlin and more.

Web æ¥­ç•Œã§ã¯ã€Go ãŒ popular ã«ãªã£ã¦ã„ã‚‹ã—ã€ç¾è·ã® 2Bãƒ»2C å‘ã‘ã‚µãƒ¼ãƒ“ã‚¹ã‚‚ Go ã‚’å¤šãä½¿ã£ã¦ã„ã‚‹ã€‚

åƒ•å€‹äººã¨ã—ã¦ã€Go ã‚’é¸æŠã™ã‚‹ã“ã¨ã«ç•°è«–ã¯ãªã„ã€‚

ä¸€æ–¹ã§ã€æ¬¡ã‚’è¦‹æ®ãˆã¦è€ƒãˆã¦ãŠãå¿…è¦ã‚‚ã‚ã‚‹ã€‚

ä½•ãŒè¨€ã„ãŸã„ã‹ã¨ã„ã†ã¨ã€ã‚ˆã‚Šæœ€é«˜ãªé¸æŠè‚¢ã¯ä½•ã‹ã‚’å¸¸ã«è€ƒãˆã¦ã„ããŸã„ã€‚æ€è€ƒåœæ­¢ã¯é€€åŒ–ã€‚

Rust ã«ã¤ã„ã¦ã€
- tutorial
- gRPC
- Rust + Wasm + Cloudflare Workers
- REST

ã¨ç¶šã‘ã¦ãã¦ã€syntax ã¯èº«ã«ã¤ã„ã¦æ¥ãŸã€‚

ã‚ˆã‚Šå®Ÿè·µçš„ãªèª²é¡Œã‚’è§£ã‘ã‚‹ã‚ˆã†ã«å®Ÿè·µã‚’é‡ã­ã¦ã„ãã€‚ãã—ã¦ã€AtCoder ã® algorithm å•é¡Œã«ã¤ã„ã¦ã‚‚è§£ã„ã¦ã„ãã€‚

## æœ¬é¡Œ
ä»Šå›ã‚‚ã€REST + Database ã® API ã‚’ Rust ã§å®Ÿè£…ã—ã€ãã‚Œã‚’ Go ã§ rewrite ã—ãŸã€‚

database ã¯ã€æ‰±ã„ã‚„ã™ã•ã®è¦³ç‚¹ã‹ã‚‰ SQLite ã«ã—ãŸã€‚

Rustã€Go ã®ã‚³ãƒ¼ãƒ‰ã‚’å…¨éƒ¨æ¶ˆã—ã¦ã€ã‚¼ãƒ­ã‹ã‚‰å®Ÿè£…ã§ãã‚‹ã¨ã“ã‚ã¾ã§å®Œäº†ã—ãŸã€‚

æ¬¡ã¯ã€Advent Calendar ã«å‘ã‘ã¦ã€ä½•ã‹ãŠé¡Œã‚’è€ƒãˆã¦ã„ãã€‚Rust ã§ Otel ã® tracer ã‚’ä½œã‚‹ãªã©ã€‚

ã‚³ãƒ¼ãƒ‰ã¯ã“ã¡ã‚‰ã€‚

https://github.com/danny-yamamoto/rust-api-samples/tree/main/users

https://github.com/danny-yamamoto/go-api-samples/tree/main/cmd/users

## Rust Web Server: /users
å®Ÿè£…ã®æ‰‹é †
1. Response ç”¨ã® struct `User` ã‚’æ›¸ã
1. Request ç”¨ã® struct `UserQuery` ã‚’æ›¸ã
1. Handler `users_handler` ã‚’æ›¸ãã€‚Query ã¨ `IntoResponse` ä»¥å¤–ã€‚
1. `main` ã‚’æ›¸ã
1. Query ã¨ `IntoResponse` ã‚’æ›¸ã
1. db ã¨ã®æ•´åˆæ€§ã‚’ãƒã‚§ãƒƒã‚¯ `cargo sqlx prepare --database-url "sqlite:./local.db"`
1. `rust-analyzer` ã®è­¦å‘Šã«å¯¾å¿œã™ã‚‹

```toml:Cargo.toml
[package]
name = "users"
version = "0.1.0"
edition = "2021"

[dependencies]
dotenv = "0.15.0"
serde = { version = "1.0.192", features = ["derive"] }
serde_json = "1.0.108"
sqlx = { version = "0.7.2", features = ["sqlite", "runtime-tokio-native-tls", "chrono", "runtime-tokio", "macros"] }
tokio = { version = "1.33.0", features = ["full"] }
axum = "0.6.20"
```

```rust:main.rs
use std::{env, sync::Arc, net::{SocketAddr, IpAddr, Ipv4Addr}};

use axum::{extract::Query, Router, routing::get, Extension, http::StatusCode, Json, response::IntoResponse};
use serde::{Serialize, Deserialize};
use dotenv::dotenv;
use sqlx::SqlitePool;

#[derive(Serialize)]
struct User {
    user_id: i64,
    email_address: Option<String>,
    created_at: Option<i64>,
    deleted: Option<i64>,
    settings: Option<String>,
}

#[derive(Deserialize)]
struct UserQuery {
    user_id: i64,
}

async fn users_handler(Query(query):Query<UserQuery>, Extension(pool):Extension<Arc<SqlitePool>>) -> impl IntoResponse {
    let selected_user_id = query.user_id;
    match sqlx::query_as!(User, "select user_id, email_address, created_at, deleted, settings from users where user_id = ?", selected_user_id).fetch_optional(&*pool).await {
        Ok(user) => (StatusCode::OK, Json(user)),
        Err(_) => (StatusCode::INTERNAL_SERVER_ERROR, Json(None::<User>)),
    }
}

#[tokio::main]
async fn main() {
    dotenv().ok();
    let key = "DATABASE_URL";
    let db_url = env::var(key).expect("key not found.");
    let pool = SqlitePool::connect(&db_url).await.expect("cannot connect.");
    let shared_pool = Arc::new(pool);
    let app = Router::new()
        .route("/users", get(users_handler))
        .layer(Extension(shared_pool));
    let addr = SocketAddr::new(IpAddr::V4(Ipv4Addr::new(127, 0, 0, 1)), 8080);
    axum::Server::bind(&addr)
        .serve(app.into_make_service())
        .await
        .unwrap();
}
```

GPT-4 ã®è§£èª¬
> ã“ã®Rustã‚³ãƒ¼ãƒ‰ã¯ã€Webã‚µãƒ¼ãƒã¨ã—ã¦æ©Ÿèƒ½ã—ã€SQLiteãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã‚’ä½¿ç”¨ã—ã¦ãƒ¦ãƒ¼ã‚¶ãƒ¼æƒ…å ±ã‚’æä¾›ã™ã‚‹APIã‚’å®Ÿè£…ã—ã¦ã„ã¾ã™ã€‚ã‚³ãƒ¼ãƒ‰ã®ä¸»è¦ãªè¦ç´ ã‚’åˆ†æã—ã€ãã®æ©Ÿèƒ½ã‚’èª¬æ˜ã—ã¾ã™ã€‚
>
> 1. ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã®ã‚¤ãƒ³ãƒãƒ¼ãƒˆ:
> stdã€axumã€serdeã€dotenvã€sqlxã¨ã„ã£ãŸè¤‡æ•°ã®ãƒ©ã‚¤ãƒ–ãƒ©ãƒªãŒã‚¤ãƒ³ãƒãƒ¼ãƒˆã•ã‚Œã¦ã„ã¾ã™ã€‚ã“ã‚Œã‚‰ã¯æ¨™æº–ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã€HTTPã‚µãƒ¼ãƒãƒ¼æ©Ÿèƒ½ã€ã‚·ãƒªã‚¢ãƒ©ã‚¤ã‚º/ãƒ‡ã‚·ãƒªã‚¢ãƒ©ã‚¤ã‚ºã€ç’°å¢ƒå¤‰æ•°ã®èª­ã¿è¾¼ã¿ã€ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹æ“ä½œã«å¿…è¦ã§ã™ã€‚
> 1. ãƒ¦ãƒ¼ã‚¶ãƒ¼æ§‹é€ ä½“ã®å®šç¾©:
> Userã¨UserQueryã¨ã„ã†2ã¤ã®æ§‹é€ ä½“ãŒå®šç¾©ã•ã‚Œã¦ã„ã¾ã™ã€‚Userã¯ãƒ¦ãƒ¼ã‚¶ãƒ¼æƒ…å ±ã‚’è¡¨ã—ã€Serializeãƒˆãƒ¬ã‚¤ãƒˆã‚’ä½¿ç”¨ã—ã¦JSONå½¢å¼ã§å‡ºåŠ›å¯èƒ½ã§ã™ã€‚UserQueryã¯ã‚¯ã‚¨ãƒªãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚’è¡¨ã—ã€Deserializeãƒˆãƒ¬ã‚¤ãƒˆã§HTTPãƒªã‚¯ã‚¨ã‚¹ãƒˆã‹ã‚‰ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—ã—ã¾ã™ã€‚
> 1. ãƒ¦ãƒ¼ã‚¶ãƒ¼æƒ…å ±å–å¾—ãƒãƒ³ãƒ‰ãƒ©:
> users_handleré–¢æ•°ã¯ã€æŒ‡å®šã•ã‚ŒãŸãƒ¦ãƒ¼ã‚¶ãƒ¼IDã«åŸºã¥ã„ã¦ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã‹ã‚‰ãƒ¦ãƒ¼ã‚¶ãƒ¼æƒ…å ±ã‚’å–å¾—ã—ã¾ã™ã€‚Queryã¨Extensionã¯ã€ãã‚Œãã‚Œã‚¯ã‚¨ãƒªãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã¨ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹æ¥ç¶šãƒ—ãƒ¼ãƒ«ã‚’å–å¾—ã™ã‚‹ãŸã‚ã«ä½¿ç”¨ã•ã‚Œã¾ã™ã€‚
> 1. ãƒ¡ã‚¤ãƒ³é–¢æ•°:
> tokio::mainã‚¢ãƒˆãƒªãƒ“ãƒ¥ãƒ¼ãƒˆã¯ã€éåŒæœŸãƒ©ãƒ³ã‚¿ã‚¤ãƒ ã‚’è¡¨ã—ã¾ã™ã€‚ç’°å¢ƒå¤‰æ•°ã‹ã‚‰ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹URLã‚’å–å¾—ã—ã€SqlitePoolã‚’ä»‹ã—ã¦SQLiteãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã«æ¥ç¶šã—ã¾ã™ã€‚Routerã‚’ä½¿ç”¨ã—ã¦ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆï¼ˆ/usersï¼‰ã‚’å®šç¾©ã—ã€users_handlerã‚’é–¢é€£ä»˜ã‘ã¾ã™ã€‚ã‚¢ãƒ‰ãƒ¬ã‚¹127.0.0.1:8080ã§ã‚µãƒ¼ãƒãƒ¼ã‚’èµ·å‹•ã—ã€HTTPãƒªã‚¯ã‚¨ã‚¹ãƒˆã‚’å¾…æ©Ÿã—ã¾ã™ã€‚ã“ã®ã‚³ãƒ¼ãƒ‰ã¯ã€æŒ‡å®šã•ã‚ŒãŸãƒ¦ãƒ¼ã‚¶ãƒ¼IDã‚’ã‚¯ã‚¨ãƒªãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã¨ã—ã¦å—ã‘å–ã‚Šã€ãã®IDã«é–¢é€£ã™ã‚‹ãƒ¦ãƒ¼ã‚¶ãƒ¼æƒ…å ±ã‚’ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã‹ã‚‰æ¤œç´¢ã—ã¦JSONå½¢å¼ã§è¿”ã™ç°¡æ˜“çš„ãªREST APIã‚’æä¾›ã—ã¾ã™ã€‚ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ã‚„ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£æ©Ÿèƒ½ã¯åŸºæœ¬çš„ã§ã™ãŒã€ã“ã‚Œã¯ã‚µãƒ¼ãƒãƒ¼ã‚µã‚¤ãƒ‰ã®Webã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã®å…¸å‹çš„ãªæ§‹é€ ã‚’ç¤ºã—ã¦ã„ã¾ã™ã€‚

`sqlx` ã«ã‚ˆã‚Šã€å®Ÿè¡Œå‰ã« Query ã®æ¤œè¨¼ã‚’è¡Œã†ã€‚
```bash
vscode âœ /workspaces/rust-api-samples/users (main) $ cargo sqlx prepare --database-url "sqlite:./local.db"
    Checking users v0.1.0 (/workspaces/rust-api-samples/users)
    Finished dev [unoptimized + debuginfo] target(s) in 5.14s
query data written to .sqlx in the current directory; please check this into version control
```

- å®Ÿè¡Œ
```bash
vscode âœ /workspaces/rust-api-samples/users (main) $ cargo run
    Finished dev [unoptimized + debuginfo] target(s) in 2.83s
     Running `target/debug/users`
```

- ãƒ†ã‚¹ãƒˆ
```bash
vscode âœ /workspaces/rust-api-samples (main) $ curl "localhost:8080/users?user_id=1" -i
HTTP/1.1 200 OK
content-type: application/json
content-length: 90
date: Sun, 12 Nov 2023 03:23:25 GMT

{"user_id":1,"email_address":"maria@example.com","created_at":0,"deleted":0,"settings":""}
vscode âœ /workspaces/rust-api-samples (main) $ 
```

## Rust to Go Conversion
å®Ÿè£…ã®æ‰‹é †
1. `User` æ§‹é€ ä½“ã‚’æ›¸ãã€‚Rust ã¨é•ã„ colon ãŒä¸è¦ã€‚
1. Handler ã‚’æ›¸ã
1. Handler ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’æ›¸ã
1. Response ç”¨ã®é–¢æ•° `respondWithJSON` ã‚’æ›¸ã
1. `UserHandler` ã‚’æ›¸ã
1. `main` ã‚’æ›¸ã
1. blank import ã‚’å¿˜ã‚Œãšã«æ›¸ã

```go:main.go
package main

import (
	"database/sql"
	"encoding/json"
	"fmt"
	"log"
	"net/http"
	"os"

	_ "github.com/mattn/go-sqlite3"
)

type User struct {
	UserId       int64  `json:"user_id"`
	EmailAddress string `json:"email_address"`
	CreatedAt    int64  `json:"created_at"`
	Deleted      int64  `json:"deleted"`
	Settings     string `json:"settings"`
}

type Handler struct {
	db *sql.DB
}

func NewHandler(db *sql.DB) *Handler {
	return &Handler{db: db}
}

func respondWithJSON(w http.ResponseWriter, statusCode int, payload interface{}) {
	response, _ := json.Marshal(payload)
	w.Header().Add("Content-Type", "application/json")
	w.WriteHeader(statusCode)
	w.Write(response)
}

func (h Handler) UserHandler(w http.ResponseWriter, r *http.Request) {
	userId := r.URL.Query().Get("user_id")
	var user User
	err := h.db.QueryRow("select * from users where user_id = ?", userId).Scan(&user.UserId, &user.EmailAddress, &user.CreatedAt, &user.Deleted, &user.Settings)
	if err != nil {
		fmt.Println(err)
		respondWithJSON(w, http.StatusInternalServerError, err)
		return
	}
	respondWithJSON(w, http.StatusOK, user)
}

func main() {
	key := "DATABASE_URL"
	dbUrl := os.Getenv(key)
	client, err := sql.Open("sqlite3", dbUrl)
	if err != nil {
		fmt.Printf("Failed to create connection: %s", err)
		return
	}
	defer client.Close()
	handler := NewHandler(client)
	http.HandleFunc("/users", handler.UserHandler)
	port := "8080"
	addr := fmt.Sprintf("0.0.0.0:%s", port)
	fmt.Printf("Listening on http://%s\n", addr)
	log.Fatal(http.ListenAndServe(addr, nil))
}
```
