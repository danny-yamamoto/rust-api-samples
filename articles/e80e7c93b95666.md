---
title: "Rust vs. Go: Implementing DI for Effective Unit Testing"
emoji: "🚀"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: []
published: false
---
Rust 初心者として、テストの実装方法について学ぶ。

テストを実装可能にするために、依存関係の逆転（DI）を取り入れる。DI は、どの開発言語でも使える。

そして、構成を変更する。`main.rs` は entorypoint。handler と構造体を `routes.rs`、`model.rs` に分ける。

これで、Unit test code を追加する準備が完了。

コードはこちら。

https://github.com/danny-yamamoto/rust-api-samples/tree/main/main

https://github.com/danny-yamamoto/go-api-samples

## How to write tests: Rust
Rust におけるテストの書き方について。
Unit tests と Integration tests の 2つある。

- Unit tests
logic 内に書く。
test code であることを明示するために、annotation `cfg(test)` を付与する。

> Unit Tests
The purpose of unit tests is to test each unit of code in isolation from the rest of the code to quickly pinpoint where code is and isn’t working as expected. You’ll put unit tests in the src directory in each file with the code that they’re testing. The convention is to create a module named tests in each file to contain the test functions and to annotate the module with cfg(test).

https://doc.rust-lang.org/book/ch11-03-test-organization.html?highlight=cfg(test)#unit-tests

`cfg(test)` を付与するのが慣例ということ。

試しに unit tests を書く。

```rust:routes.rs
#[cfg(test)]
mod users_service_tests {
    use sqlx::SqlitePool;
    use crate::routes::UserService;

    #[tokio::test]
    async fn test_fetch_users() {
        let pool = SqlitePool::connect("sqlite:./unit_test.db").await.expect("Failed to connect to database.");
        let service = UserService::new(pool);
        let user_id = 10000;
        let result = service.fetch_user(user_id).await;
        assert!(result.is_ok());
        let user = result.unwrap();
        assert!(user.is_some());
        let row = user.unwrap();
        assert_eq!(row.email_address, Some("marc@example.com".to_string()));
    }
}
```

テストを実行する
```bash
vscode ➜ /workspaces/rust-api-samples/main (main) $ cargo test
   Compiling main v0.1.0 (/workspaces/rust-api-samples/main)
    Finished test [unoptimized + debuginfo] target(s) in 1m 33s
     Running unittests src/main.rs (target/debug/deps/main-794ccb24f64c7f92)

running 3 tests
test routes::tests::err_api_response_users ... ok
test routes::tests::test_api_response_users ... ok
test routes::users_service_tests::test_fetch_users ... ok      # これ

test result: ok. 3 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.27s

vscode ➜ /workspaces/rust-api-samples/main (main) $
```

## How to write tests: Go
Go の test は、言わずと知れた `Table Driven Tests`。
mock として、database を先に用意しておく。
`setupMockDB` で初期データを投入するのもあり。もしくは、db ファイルをコミットしておく。

```bash
sqlite3 unit_test.db
```

```go
package users

import (
	"database/sql"
	"encoding/json"
	"strconv"
	"testing"
)

func setupMockDB(t *testing.T) *sql.DB {
	db, err := sql.Open("sqlite3", "../../unit_test.db")
	if err != nil {
		t.Fatalf("Failed to connect to database: %v", err)
	}
	return db
}

func TestGetUsers(t *testing.T) {
	db := setupMockDB(t)

	tests := []struct {
		name         string
		userId       int64
		expectedJSON string
		want         bool
	}{
		{"Normal pattern a", 10000, `{"user_id":10000,"email_address":"marc@example.com","created_at":0,"deleted":1,"settings":""}`, true},
		{"Normal pattern b", 100, `{"user_id":100,"email_address":"marc@example.com","created_at":1,"deleted":1,"settings":""}`, false},
		{"Failed pattern a", 100, `{"user_id":100,"email_address":"alex@example.com","created_at":1,"deleted":0,"settings":""}`, true},
	}
	for _, tc := range tests {
		user, err := GetUsers(db, UserQuery{UserId: strconv.FormatInt(tc.userId, 10)})
		if err != nil {
			t.Errorf("Error: %v", err)
		}
		userJson, err := json.Marshal(user)
		if err != nil {
			t.Errorf("Failed to marshal user data: %s", err)
		}
		if tc.want && string(userJson) != tc.expectedJSON {
			t.Errorf("Expected JSON %s for user ID %v, got %s", tc.expectedJSON, tc.userId, string(userJson))
		}
	}

}
```

## Table Driven Tests in Rust
Table Driven Tests を Rust で実践するとどうなるか。
これは、諸元があるわけではなく、個人的に考えた実装方法。

```rust:routes.rs
#[cfg(test)]
mod users_service_tests {
    use serde::{Serialize, Deserialize};
    use sqlx::SqlitePool;
    use crate::routes::UserService;

    #[derive(Debug, Serialize, Deserialize)]
    struct TestCase {
		name: String,
		user_id: i64,
		expected_json: String,
    }

    #[tokio::test]
    async fn tdt_fetch_users() {
        let pool = SqlitePool::connect("sqlite:./unit_test.db").await.expect("Failed to connect to database.");
        let service = UserService::new(pool);
        let tests = vec![
            TestCase { name: "Normal pattern a".to_string(), user_id: 10000, expected_json: "{\"user_id\":10000,\"email_address\":\"marc@example.com\",\"created_at\":0,\"deleted\":1,\"settings\":\"\"}".to_string() },
            TestCase { name: "Normal pattern b".to_string(), user_id: 100, expected_json: "{\"user_id\":100,\"email_address\":\"alex@example.com\",\"created_at\":1,\"deleted\":0,\"settings\":\"\"}".to_string() }
        ];

        for tc in tests {
            let user_id = tc.user_id;
            let result = service.fetch_user(user_id).await;
            assert!(result.is_ok());
            let user_data = result.unwrap();
            let user_json = serde_json::to_string(&user_data).expect("error");
            assert_eq!(user_json, tc.expected_json, "Failed: {}", tc.name);
        }
    }
}
```

```bash
vscode ➜ /workspaces/rust-api-samples/main (main) $ cargo test
   Compiling main v0.1.0 (/workspaces/rust-api-samples/main)
    Finished test [unoptimized + debuginfo] target(s) in 1m 36s
     Running unittests src/main.rs (target/debug/deps/main-794ccb24f64c7f92)

running 4 tests
test routes::tests::err_api_response_users ... ok
test routes::tests::test_api_response_users ... ok
test routes::users_service_tests::test_fetch_users ... ok
test routes::users_service_tests::tdt_fetch_users ... ok             # これ

test result: ok. 4 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.28s

vscode ➜ /workspaces/rust-api-samples/main (main) $ 
```

## impressions
実践的なコードは書けるようになってきた一方で、LeetCode の Graph, BFS, DFS を見ていると、algorithm に特化した学習が必要かもしれない。

「Rust できます」と言えるまでにはもう少し時間がかかりそう。
