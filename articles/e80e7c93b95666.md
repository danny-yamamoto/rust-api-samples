---
title: "Rust vs. Go: Implementing DI for Effective Unit Testing"
emoji: "🚀"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: []
published: false
---
Rust 初心者として、テストの実装方法について学ぶ。

テストを実装可能にするために、依存関係の逆転（DI）を取り入れる。DI は、どの開発言語でも使える。

そして、構成を変更する。`main.rs` は entorypoint。handler と構造体を `routes.rs`、`model.rs` に分ける。

これで、Unit test code を追加する準備が完了。

コードはこちら。

https://github.com/danny-yamamoto/rust-api-samples/tree/main/main

https://github.com/danny-yamamoto/go-api-samples

## Rust
- How to write tests
Rust におけるテストの書き方について。
Unit tests と Integration tests の 2つある。

- Unit tests
logic 内に書く。
test code であることを明示するために、annotation `cfg(test)` を付与する。

> Unit Tests
The purpose of unit tests is to test each unit of code in isolation from the rest of the code to quickly pinpoint where code is and isn’t working as expected. You’ll put unit tests in the src directory in each file with the code that they’re testing. The convention is to create a module named tests in each file to contain the test functions and to annotate the module with cfg(test).

https://doc.rust-lang.org/book/ch11-03-test-organization.html?highlight=cfg(test)#unit-tests

`cfg(test)` を付与するのが慣例ということ。

試しに unit tests を書く。

```rust:routes.rs
#[cfg(test)]
mod tests {
    use super::*;

    #[tokio::test]
    async fn test_api_response_users() {
        let user = User {
            user_id: 9999,
            email_address: Some("hoge@example.com".to_string()),
            created_at: Some(0),
            deleted: Some(0),
            settings: Some("option".to_string()),
        };
        let response = ApiResponse::UserResponse(Some(user)).into_response();
        assert_eq!(response.status(), StatusCode::OK);
    }
}
```

テストを実行する
```bash
vscode ➜ /workspaces/rust-api-samples/main (main) $ cargo test
    Finished test [unoptimized + debuginfo] target(s) in 2.66s
     Running unittests src/main.rs (target/debug/deps/main-794ccb24f64c7f92)

running 1 test
test routes::tests::test_api_response_users ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

vscode ➜ /workspaces/rust-api-samples/main (main) $ 
```

また、Unit tests を VS Code の画面から実行できる。
![unit test](image.png)

実装の手順
1. 

## Go
言わずと知れた Table Driven Tests。
mock として、database を先に用意しておく。
`setupMockDB` で初期データを投入するのもあり。もしくは、db ファイルをコミットしておく。

```bash
sqlite3 unit_test.db
```

```go
package users

import (
	"database/sql"
	"encoding/json"
	"strconv"
	"testing"
)

func setupMockDB(t *testing.T) *sql.DB {
	db, err := sql.Open("sqlite3", "../../unit_test.db")
	if err != nil {
		t.Fatalf("Failed to connect to database: %v", err)
	}
	return db
}

func TestGetUsers(t *testing.T) {
	db := setupMockDB(t)

	tests := []struct {
		name         string
		userId       int64
		expectedJSON string
		want         bool
	}{
		{"Normal pattern a", 10000, `{"user_id":10000,"email_address":"marc@example.com","created_at":0,"deleted":1,"settings":""}`, true},
		{"Normal pattern b", 100, `{"user_id":100,"email_address":"marc@example.com","created_at":1,"deleted":1,"settings":""}`, false},
		{"Failed pattern a", 100, `{"user_id":100,"email_address":"alex@example.com","created_at":1,"deleted":0,"settings":""}`, true},
	}
	for _, tc := range tests {
		user, err := GetUsers(db, UserQuery{UserId: strconv.FormatInt(tc.userId, 10)})
		if err != nil {
			t.Errorf("Error: %v", err)
		}
		userJson, err := json.Marshal(user)
		if err != nil {
			t.Errorf("Failed to marshal user data: %s", err)
		}
		if tc.want && string(userJson) != tc.expectedJSON {
			t.Errorf("Expected JSON %s for user ID %v, got %s", tc.expectedJSON, tc.userId, string(userJson))
		}
	}

}
```

## impressions
実践的なコードは書けるようになってきた一方で、LeetCode の Graph, BFS, DFS を見ていると、algorithm に特化した学習が必要かもしれない。

「Rust できます」と言えるまでにはもう少し時間がかかりそう。
