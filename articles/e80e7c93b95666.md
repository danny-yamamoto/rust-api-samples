---
title: "Rust vs. Go: Effective Unit Testing"
emoji: "🎅"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["rust","go","test","devcontainer"]
published: false
---
[Retail AI Adventurers Advent Calendar 2023](https://qiita.com/advent-calendar/2023/rai-adventurers) の投稿です。

https://qiita.com/advent-calendar/2023/rai-adventurers

[Retail AI](https://www.retail-ai.jp) は、[トライアルカンパニー](https://www.trial-net.co.jp) を軸とした小売におけるお客様の買い物体験の向上を目指す企業です。

この投稿では、本業（SRE）のかたわらで取り組む Backend について書きます。

題材は、Rust 初心者として、テストの実装方法についてです。

テストを実装可能にするために、依存関係の逆転（DI）を取り入れる方法を書きました。

それを元に Test Code を実装します。

Rust で Table Driven Tests[^1] はどうなるか？

https://github.com/danny-yamamoto/rust-api-samples/tree/main/main

https://github.com/danny-yamamoto/go-api-samples

## How to write tests: Rust
### Unit tests and Integration tests
Rust におけるテストの書き方についてです。
Unit tests と Integration tests で実装方法が異なります。

- Unit tests
logic 内に書きます。
Test Code であることを明示するために、Annotation `cfg(test)` を付与します。

以下は、Official Docs より。
> Unit Tests
The purpose of unit tests is to test each unit of code in isolation from the rest of the code to quickly pinpoint where code is and isn’t working as expected. You’ll put unit tests in the src directory in each file with the code that they’re testing. The convention is to create a module named tests in each file to contain the test functions and to annotate the module with cfg(test).

https://doc.rust-lang.org/book/ch11-03-test-organization.html?highlight=cfg(test)#unit-tests

`cfg(test)` を付与するのが慣例です。

Unit Tests を書きます。

```rust:routes.rs
#[cfg(test)]
mod users_service_tests {
    use sqlx::SqlitePool;
    use crate::routes::UserService;

    #[tokio::test]
    async fn test_fetch_users() {
        let pool = SqlitePool::connect("sqlite:./unit_test.db").await.expect("Failed to connect to database.");
        let service = UserService::new(pool);
        let user_id = 10000;
        let result = service.fetch_user(user_id).await;
        assert!(result.is_ok());
        let user = result.unwrap();
        assert!(user.is_some());
        let row = user.unwrap();
        assert_eq!(row.email_address, Some("marc@example.com".to_string()));
    }
}
```

Unit Tests をテストを実行します。`cargo test`
```bash
vscode ➜ /workspaces/rust-api-samples/main (main) $ cargo test
   Compiling main v0.1.0 (/workspaces/rust-api-samples/main)
    Finished test [unoptimized + debuginfo] target(s) in 1m 33s
     Running unittests src/main.rs (target/debug/deps/main-794ccb24f64c7f92)

running 3 tests
test routes::tests::err_api_response_users ... ok
test routes::tests::test_api_response_users ... ok
test routes::users_service_tests::test_fetch_users ... ok      # これ

test result: ok. 3 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.27s

vscode ➜ /workspaces/rust-api-samples/main (main) $
```

### Table Driven Tests in Rust
Table Driven Tests を Rust で実践するとどうなるか。
これは、諸元があるわけではなく、個人的に考えた実装方法です。

```rust:routes.rs
#[cfg(test)]
mod users_service_tests {
    use serde::{Serialize, Deserialize};
    use sqlx::SqlitePool;
    use crate::routes::UserService;

    #[derive(Debug, Serialize, Deserialize)]
    struct TestCase {
		name: String,
		user_id: i64,
		expected_json: String,
    }

    #[tokio::test]
    async fn tdt_fetch_users() {
        let pool = SqlitePool::connect("sqlite:./unit_test.db").await.expect("Failed to connect to database.");
        let service = UserService::new(pool);
        let tests = vec![
            TestCase { name: "Normal pattern a".to_string(), user_id: 10000, expected_json: "{\"user_id\":10000,\"email_address\":\"marc@example.com\",\"created_at\":0,\"deleted\":1,\"settings\":\"\"}".to_string() },
            TestCase { name: "Normal pattern b".to_string(), user_id: 100, expected_json: "{\"user_id\":100,\"email_address\":\"alex@example.com\",\"created_at\":1,\"deleted\":0,\"settings\":\"\"}".to_string() }
        ];

        for tc in tests {
            let user_id = tc.user_id;
            let result = service.fetch_user(user_id).await;
            assert!(result.is_ok());
            let user_data = result.unwrap();
            let user_json = serde_json::to_string(&user_data).expect("error");
            assert_eq!(user_json, tc.expected_json, "Failed: {}", tc.name);
        }
    }
}
```

```bash
vscode ➜ /workspaces/rust-api-samples/main (main) $ cargo test
   Compiling main v0.1.0 (/workspaces/rust-api-samples/main)
    Finished test [unoptimized + debuginfo] target(s) in 1m 36s
     Running unittests src/main.rs (target/debug/deps/main-794ccb24f64c7f92)

running 4 tests
test routes::tests::err_api_response_users ... ok
test routes::tests::test_api_response_users ... ok
test routes::users_service_tests::test_fetch_users ... ok
test routes::users_service_tests::tdt_fetch_users ... ok             # これ

test result: ok. 4 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.28s

vscode ➜ /workspaces/rust-api-samples/main (main) $ 
```

## How to write tests: Go
Go の test は、言わずと知れた `Table Driven Tests`。
mock[^2] として、database を先に用意します。
`setupMockDB` で初期データを投入するのもあり。もしくは、db ファイルをコミットしておきます。

```bash
sqlite3 unit_test.db
```

```go
package users

import (
	"database/sql"
	"encoding/json"
	"strconv"
	"testing"
)

func setupMockDB(t *testing.T) *sql.DB {
	db, err := sql.Open("sqlite3", "../../unit_test.db")
	if err != nil {
		t.Fatalf("Failed to connect to database: %v", err)
	}
	return db
}

func TestGetUsers(t *testing.T) {
	db := setupMockDB(t)

	tests := []struct {
		name         string
		userId       int64
		expectedJSON string
		want         bool
	}{
		{"Normal pattern a", 10000, `{"user_id":10000,"email_address":"marc@example.com","created_at":0,"deleted":1,"settings":""}`, true},
		{"Normal pattern b", 100, `{"user_id":100,"email_address":"marc@example.com","created_at":1,"deleted":1,"settings":""}`, false},
		{"Failed pattern a", 100, `{"user_id":100,"email_address":"alex@example.com","created_at":1,"deleted":0,"settings":""}`, true},
	}
	for _, tc := range tests {
		user, err := GetUsers(db, UserQuery{UserId: strconv.FormatInt(tc.userId, 10)})
		if err != nil {
			t.Errorf("Error: %v", err)
		}
		userJson, err := json.Marshal(user)
		if err != nil {
			t.Errorf("Failed to marshal user data: %s", err)
		}
		if tc.want && string(userJson) != tc.expectedJSON {
			t.Errorf("Expected JSON %s for user ID %v, got %s", tc.expectedJSON, tc.userId, string(userJson))
		}
	}

}
```

簡単ですが、Test Code については以上です。

この投稿をみて何か得られた方は、いいね ❤️ をお願いします。

それでは、次回のアドカレでお会いしましょう。👋

## BTW

[^1]: https://dave.cheney.net/2019/05/07/prefer-table-driven-tests
[^2]: ユニットテストで使われるテクニックの一つです。システムの一部分（例えば外部サービスやデータベース）を模擬する「モック オブジェクト」を作成し、本物のオブジェクトの代わりに使用します。
